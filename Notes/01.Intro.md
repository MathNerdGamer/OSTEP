# Introduction to Operating Systems

* When a program runs, it does three things (ignoring a bunch of extra stuff done for performance):
    1. It *fetches* an instruction from memory.
    2. It *decodes* the instruction.
    3. It *executes* the instruction.
    4. Then, it starts from the beginning for the next instruction.
    * This is known as the *von Neumann* model of computing, named after John von Neumann.

* An *operating system* is essentially software that makes it easy to run programs.

* An operating system does this is by employing a technique known as *virtualization*.
    * Virtualization is taking a physical resource and abstracting away the implementation details to its most fundamental form.
    * As a result, operating systems are sometimes called *virtual machines* (as opposed to something like VirtualBox, which is technically a *virtual machine monitor*, or *hypervisor*).
    * Figuring out how an operating system might do this is one of the main goals of this course.

* In order for users to make use of the OS, *interfaces* (aka *APIs*) are provided in the form of a *system call* (*syscall*).
    * A few hundred syscalls may be provided by an OS.
    * These syscalls allow for practically all of the things an OS is made for, such as running programs, accessing memory or devices, or anything else that needs the OS to provide that layer of abstraction for access to physical hardware.
    * As a result, an operating system is said to provide a *standard library* for such actions.

* Since virtualization allows for shared use of system resources, an OS is sometimes referred to ask a *resource manager*.
    * Resources include, but are not limited to, CPU time for running a program (or, more commonly, **many** programs concurrently) and access to hardware attached to the system in the form of persistent storage, extra compute units (i.e., a GPU), or networking.
    * The operating system, in an attempt to keep some semblance of order in all of the chaos, has to manage these resources carefully and efficiently.

## Virtualizing the CPU

File: `cpu.c`
```c
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int main(int argc, char *argv[])
{
    if (argc != 2) {
	fprintf(stderr, "usage: cpu <string>\n");
	exit(1);
    }
    char *str = argv[1];

    while (1) {
	printf("%s\n", str);
	Spin(1);
    }
    return 0;
}
```

* The above code is our first example.
    * All it does is loop forever printing a string out and calling `Spin()`.
    * What does `Spin()` even do?

File: `common.h`
```c
#ifndef __common_h__
#define __common_h__

#include <sys/time.h>
#include <sys/stat.h>
#include <assert.h>

double GetTime() {
    struct timeval t;
    int rc = gettimeofday(&t, NULL);
    assert(rc == 0);
    return (double) t.tv_sec + (double) t.tv_usec/1e6;
}

void Spin(int howlong) {
    double t = GetTime();
    while ((GetTime() - t) < (double) howlong)
	; // do nothing in loop
}

#endif // __common_h__
```

* Taking a look at the `common.h` header file, it seems `Spin()` takes an integer and, for the number of seconds specified by that integer, does nothing.

* When we run `./cpu A`, we get the following output:
    ```
    shell> ./cpu A
    A
    A
    A
    A
    ^C
    shell>
    ```
    * Here, we used `CTRL+C` to end execution.

* What about if we use `&` to start multiple versions of `./cpu` with different arguments?
    ```
    shell> ./cpu A & ./cpu B & ./cpu C & ./cpu D &
    [1] 14570
    [2] 14571
    [3] 14572
    [4] 14573
    A
    B
    C
    D
    A
    B
    C
    D
    . . .
    kill 14570 & kill 14571 & kill 14572 & kill 14573
    ```
    * Make note of the *pid* of each command so that they can be killed, or else it'll just go on forever.
    * `CTRL+C` won't work here.

* Note that we get multiple versions of our command running concurrently.
    * How the operating system decides how and when each command gets turn executing will be covered later.
    * Such decision-making is known as a *policy*.
    * It's through the policy specified by the operating system that multiple programs can share the CPU to execute.

* Allowing for multiple programs to run at seemingly the same time is an example of the operating system *virtualizing the CPU*.

## Virtualizing Memory

* Operating systems also *virtualize memory*.
    * Operating systems specify a simplistic model for *physical memory*:
        * Memory is an array of bytes.
        * To *read* from memory, one must specify an *address*.
        * To *write* (or *update*) memory, one must specify both an address and the data to be written.

* Recall that, in the von Neumann model, both the data we're operating on **and** the instructions of our program are in memory.

File: `mem.c`
```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int main(int argc, char *argv[]) {
    if (argc != 2) { 
	    fprintf(stderr, "usage: mem <value>\n"); 
	    exit(1); 
    } 
    int *p; 
    p = malloc(sizeof(int));
    assert(p != NULL);
    printf("(%d) addr pointed to by p: %p\n", (int) getpid(), p);
    *p = atoi(argv[1]); // assign value to addr stored in p
    while (1) {
	    Spin(1);
	    *p = *p + 1;
	    printf("(%d) value of p: %d\n", getpid(), *p);
    }
    return 0;
}
```

* Looking at `mem.c`:
    * We allocate an `int` on the heap and assign the address to pointer `p`.
    * In an infinite loop, we spin for a second, increment the integer pointed to by `p`, and print it out.

* Below is an example output.
    ```
    shell> ./mem 0
    (20119) addr pointed to by p: 0x5555555592a0
    (20119) value of p: 1
    (20119) value of p: 2
    (20119) value of p: 3
    (20119) value of p: 4
    (20119) value of p: 5
    (20119) value of p: 6
    (20119) value of p: 7
    (20119) value of p: 8
    (20119) value of p: 9
    ^C
    shell>
    ```

* If we run multiple instances of this, we'll notice something interesting.
    ```
    shell> ./mem 0 & ./mem 10 &
    [1] 21459
    [2] 21460
    (21459) addr pointed to by p: 0x5555555592a0
    (21460) addr pointed to by p: 0x5555555592a0
    (21459) value of p: 1
    (21460) value of p: 11
    (21459) value of p: 2
    (21460) value of p: 12
    (21459) value of p: 3
    (21460) value of p: 13
    (21459) value of p: 4
    (21460) value of p: 14
    . . .
    kill 21459 & kill 21460
    ```

* Notice that the addresses were the same, even though the programs clearly see different values at that address.
    * This is a result of memory virtualization.
    * Each program gets its own private *virtual memory address space* (or just *address space*).
    * They are isolated in their own chunks of memory, and they can run as though they have all of physical memory without worrying about stepping on another program's memory.

* The above examples were run with a security feature, *Address Space Layout Randomization* (*ASLR*), disabled.
    * To emulate this, run `echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`.
    * However, be *absolutely sure* that you re-enable full randomization afterwards using `echo 2 | sudo tee /proc/sys/kernel/randomize_va_space`.
    * If we were to run without disabling ASLR, the addresses would be different, which wouldn't demonstrate memory virtualization very well.
    * There are legitimate security reasons for why, despite each program having their own address spaces, it's still necessary to have them point to random (and probably different) addresses as the start of their stacks.
        * See: [Stack Buffer Overflow](https://en.wikipedia.org/wiki/Stack_buffer_overflow)

## Concurrency

* 